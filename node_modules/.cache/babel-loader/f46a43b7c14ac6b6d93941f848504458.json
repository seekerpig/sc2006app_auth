{"ast":null,"code":"var Promise = require('bluebird');\n\nvar Decrypt = require('../Decrypt');\n\nvar PullStream = require('../PullStream');\n\nvar Stream = require('stream');\n\nvar binary = require('binary');\n\nvar zlib = require('zlib');\n\nvar parseExtraField = require('../parseExtraField');\n\nvar Buffer = require('../Buffer');\n\nvar parseDateTime = require('../parseDateTime'); // Backwards compatibility for node versions < 8\n\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\n\nmodule.exports = function unzip(source, offset, _password, directoryVars) {\n  var file = PullStream(),\n      entry = Stream.PassThrough();\n  var req = source.stream(offset);\n  req.pipe(file).on('error', function (e) {\n    entry.emit('error', e);\n  });\n  entry.vars = file.pull(30).then(function (data) {\n    var vars = binary.parse(data).word32lu('signature').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').vars;\n    vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n    return file.pull(vars.fileNameLength).then(function (fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return file.pull(vars.extraFieldLength);\n    }).then(function (extraField) {\n      var checkEncryption;\n      vars.extra = parseExtraField(extraField, vars); // Ignore logal file header vars if the directory vars are available\n\n      if (directoryVars && directoryVars.compressedSize) vars = directoryVars;\n      if (vars.flags & 0x01) checkEncryption = file.pull(12).then(function (header) {\n        if (!_password) throw new Error('MISSING_PASSWORD');\n        var decrypt = Decrypt();\n        String(_password).split('').forEach(function (d) {\n          decrypt.update(d);\n        });\n\n        for (var i = 0; i < header.length; i++) {\n          header[i] = decrypt.decryptByte(header[i]);\n        }\n\n        vars.decrypt = decrypt;\n        vars.compressedSize -= 12;\n        var check = vars.flags & 0x8 ? vars.lastModifiedTime >> 8 & 0xff : vars.crc32 >> 24 & 0xff;\n        if (header[11] !== check) throw new Error('BAD_PASSWORD');\n        return vars;\n      });\n      return Promise.resolve(checkEncryption).then(function () {\n        entry.emit('vars', vars);\n        return vars;\n      });\n    });\n  });\n  entry.vars.then(function (vars) {\n    var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,\n        eof;\n    var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();\n\n    if (fileSizeKnown) {\n      entry.size = vars.uncompressedSize;\n      eof = vars.compressedSize;\n    } else {\n      eof = Buffer.alloc(4);\n      eof.writeUInt32LE(0x08074b50, 0);\n    }\n\n    var stream = file.stream(eof);\n    if (vars.decrypt) stream = stream.pipe(vars.decrypt.stream());\n    stream.pipe(inflater).on('error', function (err) {\n      entry.emit('error', err);\n    }).pipe(entry).on('finish', function () {\n      if (req.abort) req.abort();else if (req.close) req.close();else if (req.push) req.push();else console.log('warning - unable to close stream');\n    });\n  }).catch(function (e) {\n    entry.emit('error', e);\n  });\n  return entry;\n};","map":null,"metadata":{},"sourceType":"script"}