{"ast":null,"code":"var Stream = require('stream');\n\nvar Parse = require('./parse');\n\nvar duplexer2 = require('duplexer2');\n\nvar BufferStream = require('./BufferStream'); // Backwards compatibility for node versions < 8\n\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\n\nfunction parseOne(match, opts) {\n  var inStream = Stream.PassThrough({\n    objectMode: true\n  });\n  var outStream = Stream.PassThrough();\n  var transform = Stream.Transform({\n    objectMode: true\n  });\n  var re = match instanceof RegExp ? match : match && new RegExp(match);\n  var found;\n\n  transform._transform = function (entry, e, cb) {\n    if (found || re && !re.exec(entry.path)) {\n      entry.autodrain();\n      return cb();\n    } else {\n      found = true;\n      out.emit('entry', entry);\n      entry.on('error', function (e) {\n        outStream.emit('error', e);\n      });\n      entry.pipe(outStream).on('error', function (err) {\n        cb(err);\n      }).on('finish', function (d) {\n        cb(null, d);\n      });\n    }\n  };\n\n  inStream.pipe(Parse(opts)).on('error', function (err) {\n    outStream.emit('error', err);\n  }).pipe(transform).on('error', Object) // Silence error as its already addressed in transform\n  .on('finish', function () {\n    if (!found) outStream.emit('error', new Error('PATTERN_NOT_FOUND'));else outStream.end();\n  });\n  var out = duplexer2(inStream, outStream);\n\n  out.buffer = function () {\n    return BufferStream(outStream);\n  };\n\n  return out;\n}\n\nmodule.exports = parseOne;","map":null,"metadata":{},"sourceType":"script"}