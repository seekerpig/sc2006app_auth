{"ast":null,"code":"var binary = require('binary');\n\nvar PullStream = require('../PullStream');\n\nvar unzip = require('./unzip');\n\nvar Promise = require('bluebird');\n\nvar BufferStream = require('../BufferStream');\n\nvar parseExtraField = require('../parseExtraField');\n\nvar Buffer = require('../Buffer');\n\nvar path = require('path');\n\nvar Writer = require('fstream').Writer;\n\nvar parseDateTime = require('../parseDateTime');\n\nvar signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50, 0);\n\nfunction getCrxHeader(source) {\n  var sourceStream = source.stream(0).pipe(PullStream());\n  return sourceStream.pull(4).then(function (data) {\n    var signature = data.readUInt32LE(0);\n\n    if (signature === 0x34327243) {\n      var crxHeader;\n      return sourceStream.pull(12).then(function (data) {\n        crxHeader = binary.parse(data).word32lu('version').word32lu('pubKeyLength').word32lu('signatureLength').vars;\n      }).then(function () {\n        return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);\n      }).then(function (data) {\n        crxHeader.publicKey = data.slice(0, crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n} // Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\n\n\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  var d64loc = binary.parse(zip64CDL).word32lu('signature').word32lu('diskNumber').word64lu('offsetToStartOfCentralDirectory').word32lu('numberOfDisks').vars;\n\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n\n  var dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n  return dir64.pull(56);\n} // Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\n\n\nfunction parseZip64DirRecord(dir64record) {\n  var vars = binary.parse(dir64record).word32lu('signature').word64lu('sizeOfCentralDirectory').word16lu('version').word16lu('versionsNeededToExtract').word32lu('diskNumber').word32lu('diskStart').word64lu('numberOfRecordsOnDisk').word64lu('numberOfRecords').word64lu('sizeOfCentralDirectory').word64lu('offsetToStartOfCentralDirectory').vars;\n\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n\n  return vars;\n}\n\nmodule.exports = function centralDirectory(source, options) {\n  var endDir = PullStream(),\n      records = PullStream(),\n      tailSize = options && options.tailSize || 80,\n      sourceSize,\n      crxHeader,\n      startOffset,\n      vars;\n  if (options && options.crx) crxHeader = getCrxHeader(source);\n  return source.size().then(function (size) {\n    sourceSize = size;\n    source.stream(Math.max(0, size - tailSize)).on('error', function (error) {\n      endDir.emit('error', error);\n    }).pipe(endDir);\n    return endDir.pull(signature);\n  }).then(function () {\n    return Promise.props({\n      directory: endDir.pull(22),\n      crxHeader: crxHeader\n    });\n  }).then(function (d) {\n    var data = d.directory;\n    startOffset = d.crxHeader && d.crxHeader.size || 0;\n    vars = binary.parse(data).word32lu('signature').word16lu('diskNumber').word16lu('diskStart').word16lu('numberOfRecordsOnDisk').word16lu('numberOfRecords').word32lu('sizeOfCentralDirectory').word32lu('offsetToStartOfCentralDirectory').word16lu('commentLength').vars; // Is this zip file using zip64 format? Use same check as Go:\n    // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n    // For zip64 files, need to find zip64 central directory locator header to extract\n    // relative offset for zip64 central directory record.\n\n    if (vars.numberOfRecords == 0xffff || vars.numberOfRecords == 0xffff || vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n      // Offset to zip64 CDL is 20 bytes before normal CDR\n      var zip64CDLSize = 20;\n      var zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);\n      var zip64CDLStream = PullStream();\n      source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n      return zip64CDLStream.pull(zip64CDLSize).then(function (d) {\n        return getZip64CentralDirectory(source, d);\n      }).then(function (dir64record) {\n        vars = parseZip64DirRecord(dir64record);\n      });\n    } else {\n      vars.offsetToStartOfCentralDirectory += startOffset;\n    }\n  }).then(function () {\n    source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n\n    vars.extract = function (opts) {\n      if (!opts || !opts.path) throw new Error('PATH_MISSING');\n      return vars.files.then(function (files) {\n        return Promise.map(files, function (entry) {\n          if (entry.type == 'Directory') return; // to avoid zip slip (writing outside of the destination), we resolve\n          // the target path, and make sure it's nested in the intended\n          // destination, or not extract it otherwise.\n\n          var extractPath = path.join(opts.path, entry.path);\n\n          if (extractPath.indexOf(opts.path) != 0) {\n            return;\n          }\n\n          var writer = opts.getWriter ? opts.getWriter({\n            path: extractPath\n          }) : Writer({\n            path: extractPath\n          });\n          return new Promise(function (resolve, reject) {\n            entry.stream(opts.password).on('error', reject).pipe(writer).on('close', resolve).on('error', reject);\n          });\n        }, opts.concurrency > 1 ? {\n          concurrency: opts.concurrency || undefined\n        } : undefined);\n      });\n    };\n\n    vars.files = Promise.mapSeries(Array(vars.numberOfRecords), function () {\n      return records.pull(46).then(function (data) {\n        var vars = binary.parse(data).word32lu('signature').word16lu('versionMadeBy').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').word16lu('fileCommentLength').word16lu('diskNumber').word16lu('internalFileAttributes').word32lu('externalFileAttributes').word32lu('offsetToLocalFileHeader').vars;\n        vars.offsetToLocalFileHeader += startOffset;\n        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n        return records.pull(vars.fileNameLength).then(function (fileNameBuffer) {\n          vars.pathBuffer = fileNameBuffer;\n          vars.path = fileNameBuffer.toString('utf8');\n          vars.isUnicode = vars.flags & 0x11;\n          return records.pull(vars.extraFieldLength);\n        }).then(function (extraField) {\n          vars.extra = parseExtraField(extraField, vars);\n          return records.pull(vars.fileCommentLength);\n        }).then(function (comment) {\n          vars.comment = comment;\n          vars.type = vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(vars.path) ? 'Directory' : 'File';\n\n          vars.stream = function (_password) {\n            return unzip(source, vars.offsetToLocalFileHeader, _password, vars);\n          };\n\n          vars.buffer = function (_password) {\n            return BufferStream(vars.stream(_password));\n          };\n\n          return vars;\n        });\n      });\n    });\n    return Promise.props(vars);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}