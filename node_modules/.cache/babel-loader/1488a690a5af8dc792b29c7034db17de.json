{"ast":null,"code":"module.exports = Traverse;\n\nfunction Traverse(obj) {\n  if (!(this instanceof Traverse)) return new Traverse(obj);\n  this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n  var node = this.value;\n\n  for (var i = 0; i < ps.length; i++) {\n    var key = ps[i];\n\n    if (!Object.hasOwnProperty.call(node, key)) {\n      node = undefined;\n      break;\n    }\n\n    node = node[key];\n  }\n\n  return node;\n};\n\nTraverse.prototype.set = function (ps, value) {\n  var node = this.value;\n\n  for (var i = 0; i < ps.length - 1; i++) {\n    var key = ps[i];\n    if (!Object.hasOwnProperty.call(node, key)) node[key] = {};\n    node = node[key];\n  }\n\n  node[ps[i]] = value;\n  return value;\n};\n\nTraverse.prototype.map = function (cb) {\n  return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n  this.value = walk(this.value, cb, false);\n  return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n  var skip = arguments.length === 1;\n  var acc = skip ? this.value : init;\n  this.forEach(function (x) {\n    if (!this.isRoot || !skip) {\n      acc = cb.call(this, acc, x);\n    }\n  });\n  return acc;\n};\n\nTraverse.prototype.deepEqual = function (obj) {\n  if (arguments.length !== 1) {\n    throw new Error('deepEqual requires exactly one object to compare against');\n  }\n\n  var equal = true;\n  var node = obj;\n  this.forEach(function (y) {\n    var notEqual = function () {\n      equal = false; //this.stop();\n\n      return undefined;\n    }.bind(this); //if (node === undefined || node === null) return notEqual();\n\n\n    if (!this.isRoot) {\n      /*\n          if (!Object.hasOwnProperty.call(node, this.key)) {\n              return notEqual();\n          }\n      */\n      if (typeof node !== 'object') return notEqual();\n      node = node[this.key];\n    }\n\n    var x = node;\n    this.post(function () {\n      node = x;\n    });\n\n    var toS = function toS(o) {\n      return Object.prototype.toString.call(o);\n    };\n\n    if (this.circular) {\n      if (Traverse(obj).get(this.circular.path) !== x) notEqual();\n    } else if (typeof x !== typeof y) {\n      notEqual();\n    } else if (x === null || y === null || x === undefined || y === undefined) {\n      if (x !== y) notEqual();\n    } else if (x.__proto__ !== y.__proto__) {\n      notEqual();\n    } else if (x === y) {// nop\n    } else if (typeof x === 'function') {\n      if (x instanceof RegExp) {\n        // both regexps on account of the __proto__ check\n        if (x.toString() != y.toString()) notEqual();\n      } else if (x !== y) notEqual();\n    } else if (typeof x === 'object') {\n      if (toS(y) === '[object Arguments]' || toS(x) === '[object Arguments]') {\n        if (toS(x) !== toS(y)) {\n          notEqual();\n        }\n      } else if (x instanceof Date || y instanceof Date) {\n        if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {\n          notEqual();\n        }\n      } else {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (kx.length !== ky.length) return notEqual();\n\n        for (var i = 0; i < kx.length; i++) {\n          var k = kx[i];\n\n          if (!Object.hasOwnProperty.call(y, k)) {\n            notEqual();\n          }\n        }\n      }\n    }\n  });\n  return equal;\n};\n\nTraverse.prototype.paths = function () {\n  var acc = [];\n  this.forEach(function (x) {\n    acc.push(this.path);\n  });\n  return acc;\n};\n\nTraverse.prototype.nodes = function () {\n  var acc = [];\n  this.forEach(function (x) {\n    acc.push(this.node);\n  });\n  return acc;\n};\n\nTraverse.prototype.clone = function () {\n  var parents = [],\n      nodes = [];\n  return function clone(src) {\n    for (var i = 0; i < parents.length; i++) {\n      if (parents[i] === src) {\n        return nodes[i];\n      }\n    }\n\n    if (typeof src === 'object' && src !== null) {\n      var dst = copy(src);\n      parents.push(src);\n      nodes.push(dst);\n      Object.keys(src).forEach(function (key) {\n        dst[key] = clone(src[key]);\n      });\n      parents.pop();\n      nodes.pop();\n      return dst;\n    } else {\n      return src;\n    }\n  }(this.value);\n};\n\nfunction walk(root, cb, immutable) {\n  var path = [];\n  var parents = [];\n  var alive = true;\n  return function walker(node_) {\n    var node = immutable ? copy(node_) : node_;\n    var modifiers = {};\n    var state = {\n      node: node,\n      node_: node_,\n      path: [].concat(path),\n      parent: parents.slice(-1)[0],\n      key: path.slice(-1)[0],\n      isRoot: path.length === 0,\n      level: path.length,\n      circular: null,\n      update: function update(x) {\n        if (!state.isRoot) {\n          state.parent.node[state.key] = x;\n        }\n\n        state.node = x;\n      },\n      'delete': function _delete() {\n        delete state.parent.node[state.key];\n      },\n      remove: function remove() {\n        if (Array.isArray(state.parent.node)) {\n          state.parent.node.splice(state.key, 1);\n        } else {\n          delete state.parent.node[state.key];\n        }\n      },\n      before: function before(f) {\n        modifiers.before = f;\n      },\n      after: function after(f) {\n        modifiers.after = f;\n      },\n      pre: function pre(f) {\n        modifiers.pre = f;\n      },\n      post: function post(f) {\n        modifiers.post = f;\n      },\n      stop: function stop() {\n        alive = false;\n      }\n    };\n    if (!alive) return state;\n\n    if (typeof node === 'object' && node !== null) {\n      state.isLeaf = Object.keys(node).length == 0;\n\n      for (var i = 0; i < parents.length; i++) {\n        if (parents[i].node_ === node_) {\n          state.circular = parents[i];\n          break;\n        }\n      }\n    } else {\n      state.isLeaf = true;\n    }\n\n    state.notLeaf = !state.isLeaf;\n    state.notRoot = !state.isRoot; // use return values to update if defined\n\n    var ret = cb.call(state, state.node);\n    if (ret !== undefined && state.update) state.update(ret);\n    if (modifiers.before) modifiers.before.call(state, state.node);\n\n    if (typeof state.node == 'object' && state.node !== null && !state.circular) {\n      parents.push(state);\n      var keys = Object.keys(state.node);\n      keys.forEach(function (key, i) {\n        path.push(key);\n        if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n        var child = walker(state.node[key]);\n\n        if (immutable && Object.hasOwnProperty.call(state.node, key)) {\n          state.node[key] = child.node;\n        }\n\n        child.isLast = i == keys.length - 1;\n        child.isFirst = i == 0;\n        if (modifiers.post) modifiers.post.call(state, child);\n        path.pop();\n      });\n      parents.pop();\n    }\n\n    if (modifiers.after) modifiers.after.call(state, state.node);\n    return state;\n  }(root).node;\n}\n\nObject.keys(Traverse.prototype).forEach(function (key) {\n  Traverse[key] = function (obj) {\n    var args = [].slice.call(arguments, 1);\n    var t = Traverse(obj);\n    return t[key].apply(t, args);\n  };\n});\n\nfunction copy(src) {\n  if (typeof src === 'object' && src !== null) {\n    var dst;\n\n    if (Array.isArray(src)) {\n      dst = [];\n    } else if (src instanceof Date) {\n      dst = new Date(src);\n    } else if (src instanceof Boolean) {\n      dst = new Boolean(src);\n    } else if (src instanceof Number) {\n      dst = new Number(src);\n    } else if (src instanceof String) {\n      dst = new String(src);\n    } else {\n      dst = Object.create(Object.getPrototypeOf(src));\n    }\n\n    Object.keys(src).forEach(function (key) {\n      dst[key] = src[key];\n    });\n    return dst;\n  } else return src;\n}","map":null,"metadata":{},"sourceType":"script"}