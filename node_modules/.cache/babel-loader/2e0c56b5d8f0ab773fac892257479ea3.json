{"ast":null,"code":"var Chainsaw = require('chainsaw');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Buffers = require('buffers');\n\nvar Vars = require('./lib/vars.js');\n\nvar Stream = require('stream').Stream;\n\nexports = module.exports = function (bufOrEm, eventName) {\n  if (Buffer.isBuffer(bufOrEm)) {\n    return exports.parse(bufOrEm);\n  }\n\n  var s = exports.stream();\n\n  if (bufOrEm && bufOrEm.pipe) {\n    bufOrEm.pipe(s);\n  } else if (bufOrEm) {\n    bufOrEm.on(eventName || 'data', function (buf) {\n      s.write(buf);\n    });\n    bufOrEm.on('end', function () {\n      s.end();\n    });\n  }\n\n  return s;\n};\n\nexports.stream = function (input) {\n  if (input) return exports.apply(null, arguments);\n  var _pending = null;\n\n  function getBytes(bytes, _cb, skip) {\n    _pending = {\n      bytes: bytes,\n      skip: skip,\n      cb: function cb(buf) {\n        _pending = null;\n\n        _cb(buf);\n      }\n    };\n    dispatch();\n  }\n\n  var offset = null;\n\n  function dispatch() {\n    if (!_pending) {\n      if (caughtEnd) done = true;\n      return;\n    }\n\n    if (typeof _pending === 'function') {\n      _pending();\n    } else {\n      var bytes = offset + _pending.bytes;\n\n      if (buffers.length >= bytes) {\n        var buf;\n\n        if (offset == null) {\n          buf = buffers.splice(0, bytes);\n\n          if (!_pending.skip) {\n            buf = buf.slice();\n          }\n        } else {\n          if (!_pending.skip) {\n            buf = buffers.slice(offset, bytes);\n          }\n\n          offset = bytes;\n        }\n\n        if (_pending.skip) {\n          _pending.cb();\n        } else {\n          _pending.cb(buf);\n        }\n      }\n    }\n  }\n\n  function builder(saw) {\n    function next() {\n      if (!done) saw.next();\n    }\n\n    var self = words(function (bytes, cb) {\n      return function (name) {\n        getBytes(bytes, function (buf) {\n          vars.set(name, cb(buf));\n          next();\n        });\n      };\n    });\n\n    self.tap = function (cb) {\n      saw.nest(cb, vars.store);\n    };\n\n    self.into = function (key, cb) {\n      if (!vars.get(key)) vars.set(key, {});\n      var parent = vars;\n      vars = Vars(parent.get(key));\n      saw.nest(function () {\n        cb.apply(this, arguments);\n        this.tap(function () {\n          vars = parent;\n        });\n      }, vars.store);\n    };\n\n    self.flush = function () {\n      vars.store = {};\n      next();\n    };\n\n    self.loop = function (cb) {\n      var end = false;\n      saw.nest(false, function loop() {\n        this.vars = vars.store;\n        cb.call(this, function () {\n          end = true;\n          next();\n        }, vars.store);\n        this.tap(function () {\n          if (end) saw.next();else loop.call(this);\n        }.bind(this));\n      }, vars.store);\n    };\n\n    self.buffer = function (name, bytes) {\n      if (typeof bytes === 'string') {\n        bytes = vars.get(bytes);\n      }\n\n      getBytes(bytes, function (buf) {\n        vars.set(name, buf);\n        next();\n      });\n    };\n\n    self.skip = function (bytes) {\n      if (typeof bytes === 'string') {\n        bytes = vars.get(bytes);\n      }\n\n      getBytes(bytes, function () {\n        next();\n      });\n    };\n\n    self.scan = function find(name, search) {\n      if (typeof search === 'string') {\n        search = new Buffer(search);\n      } else if (!Buffer.isBuffer(search)) {\n        throw new Error('search must be a Buffer or a string');\n      }\n\n      var taken = 0;\n\n      _pending = function pending() {\n        var pos = buffers.indexOf(search, offset + taken);\n        var i = pos - offset - taken;\n\n        if (pos !== -1) {\n          _pending = null;\n\n          if (offset != null) {\n            vars.set(name, buffers.slice(offset, offset + taken + i));\n            offset += taken + i + search.length;\n          } else {\n            vars.set(name, buffers.slice(0, taken + i));\n            buffers.splice(0, taken + i + search.length);\n          }\n\n          next();\n          dispatch();\n        } else {\n          i = Math.max(buffers.length - search.length - offset - taken, 0);\n        }\n\n        taken += i;\n      };\n\n      dispatch();\n    };\n\n    self.peek = function (cb) {\n      offset = 0;\n      saw.nest(function () {\n        cb.call(this, vars.store);\n        this.tap(function () {\n          offset = null;\n        });\n      });\n    };\n\n    return self;\n  }\n\n  ;\n  var stream = Chainsaw.light(builder);\n  stream.writable = true;\n  var buffers = Buffers();\n\n  stream.write = function (buf) {\n    buffers.push(buf);\n    dispatch();\n  };\n\n  var vars = Vars();\n  var done = false,\n      caughtEnd = false;\n\n  stream.end = function () {\n    caughtEnd = true;\n  };\n\n  stream.pipe = Stream.prototype.pipe;\n  Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n    stream[name] = EventEmitter.prototype[name];\n  });\n  return stream;\n};\n\nexports.parse = function parse(buffer) {\n  var self = words(function (bytes, cb) {\n    return function (name) {\n      if (offset + bytes <= buffer.length) {\n        var buf = buffer.slice(offset, offset + bytes);\n        offset += bytes;\n        vars.set(name, cb(buf));\n      } else {\n        vars.set(name, null);\n      }\n\n      return self;\n    };\n  });\n  var offset = 0;\n  var vars = Vars();\n  self.vars = vars.store;\n\n  self.tap = function (cb) {\n    cb.call(self, vars.store);\n    return self;\n  };\n\n  self.into = function (key, cb) {\n    if (!vars.get(key)) {\n      vars.set(key, {});\n    }\n\n    var parent = vars;\n    vars = Vars(parent.get(key));\n    cb.call(self, vars.store);\n    vars = parent;\n    return self;\n  };\n\n  self.loop = function (cb) {\n    var end = false;\n\n    var ender = function ender() {\n      end = true;\n    };\n\n    while (end === false) {\n      cb.call(self, ender, vars.store);\n    }\n\n    return self;\n  };\n\n  self.buffer = function (name, size) {\n    if (typeof size === 'string') {\n      size = vars.get(size);\n    }\n\n    var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n    offset += size;\n    vars.set(name, buf);\n    return self;\n  };\n\n  self.skip = function (bytes) {\n    if (typeof bytes === 'string') {\n      bytes = vars.get(bytes);\n    }\n\n    offset += bytes;\n    return self;\n  };\n\n  self.scan = function (name, search) {\n    if (typeof search === 'string') {\n      search = new Buffer(search);\n    } else if (!Buffer.isBuffer(search)) {\n      throw new Error('search must be a Buffer or a string');\n    }\n\n    vars.set(name, null); // simple but slow string search\n\n    for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n      for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++) {\n        ;\n      }\n\n      if (j === search.length) break;\n    }\n\n    vars.set(name, buffer.slice(offset, offset + i));\n    offset += i + search.length;\n    return self;\n  };\n\n  self.peek = function (cb) {\n    var was = offset;\n    cb.call(self, vars.store);\n    offset = was;\n    return self;\n  };\n\n  self.flush = function () {\n    vars.store = {};\n    return self;\n  };\n\n  self.eof = function () {\n    return offset >= buffer.length;\n  };\n\n  return self;\n}; // convert byte strings to unsigned little endian numbers\n\n\nfunction decodeLEu(bytes) {\n  var acc = 0;\n\n  for (var i = 0; i < bytes.length; i++) {\n    acc += Math.pow(256, i) * bytes[i];\n  }\n\n  return acc;\n} // convert byte strings to unsigned big endian numbers\n\n\nfunction decodeBEu(bytes) {\n  var acc = 0;\n\n  for (var i = 0; i < bytes.length; i++) {\n    acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n  }\n\n  return acc;\n} // convert byte strings to signed big endian numbers\n\n\nfunction decodeBEs(bytes) {\n  var val = decodeBEu(bytes);\n\n  if ((bytes[0] & 0x80) == 0x80) {\n    val -= Math.pow(256, bytes.length);\n  }\n\n  return val;\n} // convert byte strings to signed little endian numbers\n\n\nfunction decodeLEs(bytes) {\n  var val = decodeLEu(bytes);\n\n  if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n    val -= Math.pow(256, bytes.length);\n  }\n\n  return val;\n}\n\nfunction words(decode) {\n  var self = {};\n  [1, 2, 4, 8].forEach(function (bytes) {\n    var bits = bytes * 8;\n    self['word' + bits + 'le'] = self['word' + bits + 'lu'] = decode(bytes, decodeLEu);\n    self['word' + bits + 'ls'] = decode(bytes, decodeLEs);\n    self['word' + bits + 'be'] = self['word' + bits + 'bu'] = decode(bytes, decodeBEu);\n    self['word' + bits + 'bs'] = decode(bytes, decodeBEs);\n  }); // word8be(n) == word8le(n) for all n\n\n  self.word8 = self.word8u = self.word8be;\n  self.word8s = self.word8bs;\n  return self;\n}","map":null,"metadata":{},"sourceType":"script"}