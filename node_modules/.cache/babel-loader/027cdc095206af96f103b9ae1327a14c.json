{"ast":null,"code":"var util = require('util');\n\nvar zlib = require('zlib');\n\nvar Stream = require('stream');\n\nvar binary = require('binary');\n\nvar Promise = require('bluebird');\n\nvar PullStream = require('./PullStream');\n\nvar NoopStream = require('./NoopStream');\n\nvar BufferStream = require('./BufferStream');\n\nvar parseExtraField = require('./parseExtraField');\n\nvar Buffer = require('./Buffer');\n\nvar parseDateTime = require('./parseDateTime'); // Backwards compatibility for node versions < 8\n\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\nvar endDirectorySignature = Buffer.alloc(4);\nendDirectorySignature.writeUInt32LE(0x06054b50, 0);\n\nfunction Parse(opts) {\n  if (!(this instanceof Parse)) {\n    return new Parse(opts);\n  }\n\n  var self = this;\n  self._opts = opts || {\n    verbose: false\n  };\n  PullStream.call(self, self._opts);\n  self.on('finish', function () {\n    self.emit('close');\n  });\n\n  self._readRecord().catch(function (e) {\n    if (!self.__emittedError || self.__emittedError !== e) self.emit('error', e);\n  });\n}\n\nutil.inherits(Parse, PullStream);\n\nParse.prototype._readRecord = function () {\n  var self = this;\n  return self.pull(4).then(function (data) {\n    if (data.length === 0) return;\n    var signature = data.readUInt32LE(0);\n\n    if (signature === 0x34327243) {\n      return self._readCrxHeader();\n    }\n\n    if (signature === 0x04034b50) {\n      return self._readFile();\n    } else if (signature === 0x02014b50) {\n      self.__ended = true;\n      return self._readCentralDirectoryFileHeader();\n    } else if (signature === 0x06054b50) {\n      return self._readEndOfCentralDirectoryRecord();\n    } else if (self.__ended) {\n      return self.pull(endDirectorySignature).then(function () {\n        return self._readEndOfCentralDirectoryRecord();\n      });\n    } else self.emit('error', new Error('invalid signature: 0x' + signature.toString(16)));\n  });\n};\n\nParse.prototype._readCrxHeader = function () {\n  var self = this;\n  return self.pull(12).then(function (data) {\n    self.crxHeader = binary.parse(data).word32lu('version').word32lu('pubKeyLength').word32lu('signatureLength').vars;\n    return self.pull(self.crxHeader.pubKeyLength + self.crxHeader.signatureLength);\n  }).then(function (data) {\n    self.crxHeader.publicKey = data.slice(0, self.crxHeader.pubKeyLength);\n    self.crxHeader.signature = data.slice(self.crxHeader.pubKeyLength);\n    self.emit('crx-header', self.crxHeader);\n    return self._readRecord();\n  });\n};\n\nParse.prototype._readFile = function () {\n  var self = this;\n  return self.pull(26).then(function (data) {\n    var vars = binary.parse(data).word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').vars;\n    vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n    if (self.crxHeader) vars.crxHeader = self.crxHeader;\n    return self.pull(vars.fileNameLength).then(function (fileNameBuffer) {\n      var fileName = fileNameBuffer.toString('utf8');\n      var entry = Stream.PassThrough();\n      var __autodraining = false;\n\n      entry.autodrain = function () {\n        __autodraining = true;\n        var draining = entry.pipe(NoopStream());\n\n        draining.promise = function () {\n          return new Promise(function (resolve, reject) {\n            draining.on('finish', resolve);\n            draining.on('error', reject);\n          });\n        };\n\n        return draining;\n      };\n\n      entry.buffer = function () {\n        return BufferStream(entry);\n      };\n\n      entry.path = fileName;\n      entry.props = {};\n      entry.props.path = fileName;\n      entry.props.pathBuffer = fileNameBuffer;\n      entry.props.flags = {\n        \"isUnicode\": vars.flags & 0x11\n      };\n      entry.type = vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(fileName) ? 'Directory' : 'File';\n\n      if (self._opts.verbose) {\n        if (entry.type === 'Directory') {\n          console.log('   creating:', fileName);\n        } else if (entry.type === 'File') {\n          if (vars.compressionMethod === 0) {\n            console.log(' extracting:', fileName);\n          } else {\n            console.log('  inflating:', fileName);\n          }\n        }\n      }\n\n      return self.pull(vars.extraFieldLength).then(function (extraField) {\n        var extra = parseExtraField(extraField, vars);\n        entry.vars = vars;\n        entry.extra = extra;\n\n        if (self._opts.forceStream) {\n          self.push(entry);\n        } else {\n          self.emit('entry', entry);\n          if (self._readableState.pipesCount || self._readableState.pipes && self._readableState.pipes.length) self.push(entry);\n        }\n\n        if (self._opts.verbose) console.log({\n          filename: fileName,\n          vars: vars,\n          extra: extra\n        });\n        var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0,\n            eof;\n        entry.__autodraining = __autodraining; // expose __autodraining for test purposes\n\n        var inflater = vars.compressionMethod && !__autodraining ? zlib.createInflateRaw() : Stream.PassThrough();\n\n        if (fileSizeKnown) {\n          entry.size = vars.uncompressedSize;\n          eof = vars.compressedSize;\n        } else {\n          eof = Buffer.alloc(4);\n          eof.writeUInt32LE(0x08074b50, 0);\n        }\n\n        return new Promise(function (resolve, reject) {\n          self.stream(eof).pipe(inflater).on('error', function (err) {\n            self.emit('error', err);\n          }).pipe(entry).on('finish', function () {\n            return fileSizeKnown ? self._readRecord().then(resolve).catch(reject) : self._processDataDescriptor(entry).then(resolve).catch(reject);\n          });\n        });\n      });\n    });\n  });\n};\n\nParse.prototype._processDataDescriptor = function (entry) {\n  var self = this;\n  return self.pull(16).then(function (data) {\n    var vars = binary.parse(data).word32lu('dataDescriptorSignature').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').vars;\n    entry.size = vars.uncompressedSize;\n    return self._readRecord();\n  });\n};\n\nParse.prototype._readCentralDirectoryFileHeader = function () {\n  var self = this;\n  return self.pull(42).then(function (data) {\n    var vars = binary.parse(data).word16lu('versionMadeBy').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').word16lu('fileCommentLength').word16lu('diskNumber').word16lu('internalFileAttributes').word32lu('externalFileAttributes').word32lu('offsetToLocalFileHeader').vars;\n    return self.pull(vars.fileNameLength).then(function (fileName) {\n      vars.fileName = fileName.toString('utf8');\n      return self.pull(vars.extraFieldLength);\n    }).then(function (extraField) {\n      return self.pull(vars.fileCommentLength);\n    }).then(function (fileComment) {\n      return self._readRecord();\n    });\n  });\n};\n\nParse.prototype._readEndOfCentralDirectoryRecord = function () {\n  var self = this;\n  return self.pull(18).then(function (data) {\n    var vars = binary.parse(data).word16lu('diskNumber').word16lu('diskStart').word16lu('numberOfRecordsOnDisk').word16lu('numberOfRecords').word32lu('sizeOfCentralDirectory').word32lu('offsetToStartOfCentralDirectory').word16lu('commentLength').vars;\n    return self.pull(vars.commentLength).then(function (comment) {\n      comment = comment.toString('utf8');\n      self.end();\n      self.push(null);\n    });\n  });\n};\n\nParse.prototype.promise = function () {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    self.on('finish', resolve);\n    self.on('error', reject);\n  });\n};\n\nmodule.exports = Parse;","map":null,"metadata":{},"sourceType":"script"}