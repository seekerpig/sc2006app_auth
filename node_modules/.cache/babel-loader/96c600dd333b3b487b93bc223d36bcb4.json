{"ast":null,"code":"module.exports = Extract;\n\nvar Parse = require('./parse');\n\nvar Writer = require('fstream').Writer;\n\nvar path = require('path');\n\nvar stream = require('stream');\n\nvar duplexer2 = require('duplexer2');\n\nvar Promise = require('bluebird');\n\nfunction Extract(opts) {\n  // make sure path is normalized before using it\n  opts.path = path.resolve(path.normalize(opts.path));\n  var parser = new Parse(opts);\n  var outStream = new stream.Writable({\n    objectMode: true\n  });\n\n  outStream._write = function (entry, encoding, cb) {\n    if (entry.type == 'Directory') return cb(); // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n\n    var extractPath = path.join(opts.path, entry.path);\n\n    if (extractPath.indexOf(opts.path) != 0) {\n      return cb();\n    }\n\n    var writer = opts.getWriter ? opts.getWriter({\n      path: extractPath\n    }) : Writer({\n      path: extractPath\n    });\n    entry.pipe(writer).on('error', cb).on('close', cb);\n  };\n\n  var extract = duplexer2(parser, outStream);\n  parser.once('crx-header', function (crxHeader) {\n    extract.crxHeader = crxHeader;\n  });\n  parser.pipe(outStream).on('finish', function () {\n    extract.emit('close');\n  });\n\n  extract.promise = function () {\n    return new Promise(function (resolve, reject) {\n      extract.on('close', resolve);\n      extract.on('error', reject);\n    });\n  };\n\n  return extract;\n}","map":null,"metadata":{},"sourceType":"script"}