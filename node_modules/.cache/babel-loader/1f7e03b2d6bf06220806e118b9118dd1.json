{"ast":null,"code":"var Stream = require('stream');\n\nvar Promise = require('bluebird');\n\nvar util = require('util');\n\nvar Buffer = require('./Buffer');\n\nvar strFunction = 'function'; // Backwards compatibility for node versions < 8\n\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\n\nfunction PullStream() {\n  if (!(this instanceof PullStream)) return new PullStream();\n  Stream.Duplex.call(this, {\n    decodeStrings: false,\n    objectMode: true\n  });\n  this.buffer = Buffer.from('');\n  var self = this;\n  self.on('finish', function () {\n    self.finished = true;\n    self.emit('chunk', false);\n  });\n}\n\nutil.inherits(PullStream, Stream.Duplex);\n\nPullStream.prototype._write = function (chunk, e, cb) {\n  this.buffer = Buffer.concat([this.buffer, chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n}; // The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\n\n\nPullStream.prototype.stream = function (eof, includeEof) {\n  var p = Stream.PassThrough();\n  var done,\n      self = this;\n\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      var callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n\n  function pull() {\n    var packet;\n\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0, eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = !eof;\n      } else {\n        var match = self.buffer.indexOf(eof);\n\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match;\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0, match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          var len = self.buffer.length - eof.length;\n\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0, len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n\n      if (packet) p.write(packet, function () {\n        if (self.buffer.length === 0 || eof.length && self.buffer.length <= eof.length) cb();\n      });\n    }\n\n    if (!done) {\n      if (self.finished && !this.__ended) {\n        self.removeListener('chunk', pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        this.__ended = true;\n        return;\n      }\n    } else {\n      self.removeListener('chunk', pull);\n      p.end();\n    }\n  }\n\n  self.on('chunk', pull);\n  pull();\n  return p;\n};\n\nPullStream.prototype.pull = function (eof, includeEof) {\n  if (eof === 0) return Promise.resolve(''); // If we already have the required data in buffer\n  // we can resolve the request immediately\n\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    var data = this.buffer.slice(0, eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  } // Otherwise we stream until we have it\n\n\n  var buffer = Buffer.from(''),\n      self = this;\n  var concatStream = Stream.Transform();\n\n  concatStream._transform = function (d, e, cb) {\n    buffer = Buffer.concat([buffer, d]);\n    cb();\n  };\n\n  var rejectHandler;\n  var pullStreamRejectHandler;\n  return new Promise(function (resolve, reject) {\n    rejectHandler = reject;\n\n    pullStreamRejectHandler = function pullStreamRejectHandler(e) {\n      self.__emittedError = e;\n      reject(e);\n    };\n\n    if (self.finished) return reject(new Error('FILE_ENDED'));\n    self.once('error', pullStreamRejectHandler); // reject any errors from pullstream itself\n\n    self.stream(eof, includeEof).on('error', reject).pipe(concatStream).on('finish', function () {\n      resolve(buffer);\n    }).on('error', reject);\n  }).finally(function () {\n    self.removeListener('error', rejectHandler);\n    self.removeListener('error', pullStreamRejectHandler);\n  });\n};\n\nPullStream.prototype._read = function () {};\n\nmodule.exports = PullStream;","map":null,"metadata":{},"sourceType":"script"}