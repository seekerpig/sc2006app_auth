{"ast":null,"code":"module.exports = Buffers;\n\nfunction Buffers(bufs) {\n  if (!(this instanceof Buffers)) return new Buffers(bufs);\n  this.buffers = bufs || [];\n  this.length = this.buffers.reduce(function (size, buf) {\n    return size + buf.length;\n  }, 0);\n}\n\nBuffers.prototype.push = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!Buffer.isBuffer(arguments[i])) {\n      throw new TypeError('Tried to push a non-buffer');\n    }\n  }\n\n  for (var i = 0; i < arguments.length; i++) {\n    var buf = arguments[i];\n    this.buffers.push(buf);\n    this.length += buf.length;\n  }\n\n  return this.length;\n};\n\nBuffers.prototype.unshift = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    if (!Buffer.isBuffer(arguments[i])) {\n      throw new TypeError('Tried to unshift a non-buffer');\n    }\n  }\n\n  for (var i = 0; i < arguments.length; i++) {\n    var buf = arguments[i];\n    this.buffers.unshift(buf);\n    this.length += buf.length;\n  }\n\n  return this.length;\n};\n\nBuffers.prototype.copy = function (dst, dStart, start, end) {\n  return this.slice(start, end).copy(dst, dStart, 0, end - start);\n};\n\nBuffers.prototype.splice = function (i, howMany) {\n  var buffers = this.buffers;\n  var index = i >= 0 ? i : this.length - i;\n  var reps = [].slice.call(arguments, 2);\n\n  if (howMany === undefined) {\n    howMany = this.length - index;\n  } else if (howMany > this.length - index) {\n    howMany = this.length - index;\n  }\n\n  for (var i = 0; i < reps.length; i++) {\n    this.length += reps[i].length;\n  }\n\n  var removed = new Buffers();\n  var bytes = 0;\n  var startBytes = 0;\n\n  for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {\n    startBytes += buffers[ii].length;\n  }\n\n  if (index - startBytes > 0) {\n    var start = index - startBytes;\n\n    if (start + howMany < buffers[ii].length) {\n      removed.push(buffers[ii].slice(start, start + howMany));\n      var orig = buffers[ii]; //var buf = new Buffer(orig.length - howMany);\n\n      var buf0 = new Buffer(start);\n\n      for (var i = 0; i < start; i++) {\n        buf0[i] = orig[i];\n      }\n\n      var buf1 = new Buffer(orig.length - start - howMany);\n\n      for (var i = start + howMany; i < orig.length; i++) {\n        buf1[i - howMany - start] = orig[i];\n      }\n\n      if (reps.length > 0) {\n        var reps_ = reps.slice();\n        reps_.unshift(buf0);\n        reps_.push(buf1);\n        buffers.splice.apply(buffers, [ii, 1].concat(reps_));\n        ii += reps_.length;\n        reps = [];\n      } else {\n        buffers.splice(ii, 1, buf0, buf1); //buffers[ii] = buf;\n\n        ii += 2;\n      }\n    } else {\n      removed.push(buffers[ii].slice(start));\n      buffers[ii] = buffers[ii].slice(0, start);\n      ii++;\n    }\n  }\n\n  if (reps.length > 0) {\n    buffers.splice.apply(buffers, [ii, 0].concat(reps));\n    ii += reps.length;\n  }\n\n  while (removed.length < howMany) {\n    var buf = buffers[ii];\n    var len = buf.length;\n    var take = Math.min(len, howMany - removed.length);\n\n    if (take === len) {\n      removed.push(buf);\n      buffers.splice(ii, 1);\n    } else {\n      removed.push(buf.slice(0, take));\n      buffers[ii] = buffers[ii].slice(take);\n    }\n  }\n\n  this.length -= removed.length;\n  return removed;\n};\n\nBuffers.prototype.slice = function (i, j) {\n  var buffers = this.buffers;\n  if (j === undefined) j = this.length;\n  if (i === undefined) i = 0;\n  if (j > this.length) j = this.length;\n  var startBytes = 0;\n\n  for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {\n    startBytes += buffers[si].length;\n  }\n\n  var target = new Buffer(j - i);\n  var ti = 0;\n\n  for (var ii = si; ti < j - i && ii < buffers.length; ii++) {\n    var len = buffers[ii].length;\n    var start = ti === 0 ? i - startBytes : 0;\n    var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;\n    buffers[ii].copy(target, ti, start, end);\n    ti += end - start;\n  }\n\n  return target;\n};\n\nBuffers.prototype.pos = function (i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  var l = i,\n      bi = 0,\n      bu = null;\n\n  for (;;) {\n    bu = this.buffers[bi];\n\n    if (l < bu.length) {\n      return {\n        buf: bi,\n        offset: l\n      };\n    } else {\n      l -= bu.length;\n    }\n\n    bi++;\n  }\n};\n\nBuffers.prototype.get = function get(i) {\n  var pos = this.pos(i);\n  return this.buffers[pos.buf].get(pos.offset);\n};\n\nBuffers.prototype.set = function set(i, b) {\n  var pos = this.pos(i);\n  return this.buffers[pos.buf].set(pos.offset, b);\n};\n\nBuffers.prototype.indexOf = function (needle, offset) {\n  if (\"string\" === typeof needle) {\n    needle = new Buffer(needle);\n  } else if (needle instanceof Buffer) {// already a buffer\n  } else {\n    throw new Error('Invalid type for a search string');\n  }\n\n  if (!needle.length) {\n    return 0;\n  }\n\n  if (!this.length) {\n    return -1;\n  }\n\n  var i = 0,\n      j = 0,\n      match = 0,\n      mstart,\n      pos = 0; // start search from a particular point in the virtual buffer\n\n  if (offset) {\n    var p = this.pos(offset);\n    i = p.buf;\n    j = p.offset;\n    pos = offset;\n  } // for each character in virtual buffer\n\n\n  for (;;) {\n    while (j >= this.buffers[i].length) {\n      j = 0;\n      i++;\n\n      if (i >= this.buffers.length) {\n        // search string not found\n        return -1;\n      }\n    }\n\n    var char = this.buffers[i][j];\n\n    if (char == needle[match]) {\n      // keep track where match started\n      if (match == 0) {\n        mstart = {\n          i: i,\n          j: j,\n          pos: pos\n        };\n      }\n\n      match++;\n\n      if (match == needle.length) {\n        // full match\n        return mstart.pos;\n      }\n    } else if (match != 0) {\n      // a partial match ended, go back to match starting position\n      // this will continue the search at the next character\n      i = mstart.i;\n      j = mstart.j;\n      pos = mstart.pos;\n      match = 0;\n    }\n\n    j++;\n    pos++;\n  }\n};\n\nBuffers.prototype.toBuffer = function () {\n  return this.slice();\n};\n\nBuffers.prototype.toString = function (encoding, start, end) {\n  return this.slice(start, end).toString(encoding);\n};","map":null,"metadata":{},"sourceType":"script"}